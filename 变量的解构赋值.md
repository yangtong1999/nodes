####  变量的解构赋值
ES6允许按照一定模式从数组和对象中提取值，然后对于变量进行赋值，这被称为解构。

###### 数组的解构赋值
```
let [a,b,c] = [1, 2,3];
```
从数组中提取值，按照对应的位置进行赋值。本质上属于"模式匹配

结构不成功，变量的值等于undefined

不完全解构：等号左边的模式只匹配一部分右边的数组，解构可以成功

解构允许指定默认值

```
let [foo = true] = [];
foo//true
```
==如果一个数组成员不严格等于undefined，默认值是不会生效的==

如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到时才会求值

默认值可以引用解构赋值的其他变量，但是这个变量必须已经声明

###### 对象的解构赋值


```
let {foo,bar} = {foo:"aaa",bar:"bbb"};
foo//"aaa"
bar //"bbb"
```
如果变量名与属性名不一致，必须写成下面的这样

```
var {foo:baz} = {foo:"aaa",bar:"bbb"};
baz//"aaa"
```
对象的解构赋值是下面的形式的简写

```
let {foo:foo,bar:bar} = {foo:"aaa",bar:"bbb"};
```
==对象的解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量，真正被赋值的的是后者，而不是前者==

```
let {foo:baz} = {foo:"aaa",bar:"bbb"};

```
foo为匹配的模式，baz才是变量，真正被赋值的是baz，而不是模式foo。

p作为变量赋值

```
let obj = {
    p:[
       'hello',
       {
           y:'world'
       }
    ]
};
let{p,p:[x,{y}]} = obj;
x//"hello"
y//"world"
p//["hello",{y:"world"}]
```

```
var node = {
    loc:{
        start:{
            line:1,
            column:5
        }
    }
};
var {loc,loc:{start},loc:{start:{line}}} = node;
line//1
loc //Object{start:Object}
start//Object{line:1,column:5}
```
嵌套赋值的例子

```
let obj = {}；
let arr = [];

({foo:obj.prop,bar:arr[0]} = {foo:123,bar:true});

obj//{prop:123}
arr//[true]
```
对象的解构也可以指定默认值

同样的是：对象的默认值生效的条件是，对象的属性值严格等于undefined

如果结构模式是嵌套的对象，而且子对象所在的父属性不存在，将会报错

将一个已经声明的变量用于解构赋值

```
let x;

{x} = {x:1};
//程序会报错
```
js引擎会将{x}理解成一个代码块，从而发生语法错误

解决方法：不要将大括号写在行首。

```
let x;

({x} = {x:1};)
```
==解构赋值允许等号的左边模式之中不放任何变量名==


```
({} = 'abc');
```
虽然表达式毫无意义，但是语法合法，可以执行

###### 字符串的解构赋值
此时字符串被解析成为一个类似于数组的对象


```
const [a,b,c,d,e] = 'hello';
a//"h"
b//"e"
c//"l"
d//"l"
e//"o"
```
类似于数组的对象都有一个length属性，因此可以对于这个属性进行解构赋值

```
let {length:len} = 'hello';
len //5
```
###### 数值和布尔值的解构赋值
```
let {toString:s} = 123;
s ===Number.prototype.toString//true

let {toString:s} = true;
s ===Boolean.prototype.toString//true
```
toString将一个逻辑值转化为布尔值

==只要等号右边的值不是对象或者对象或者数组，就先将其转化为对象。==

undefined和null无法转化为对象，所以对于它们进行解构的时候都会报错。

###### 函数参数的解构赋值


```
function add([x,y]){
    return x + y;
}
add([1,2]);//3
```
函数参数的解构也可以使用默认值

###### 圆括号问题
规定，==只要有可能导致解构的歧义，就不得使用圆括号==

不能使用圆括号的三种情况：

- 变量声明语句
- 函数参数
- 赋值语句的模式

可以使用圆括号的情况：赋值语句的非模式部分可以使用圆括号

###### 变量的解构赋值的用途
- 交换变量的值
- 从函数返回多个值(放在数组或者对象里面，用解构取出这些值
- 函数参数的定义
- 提取json数据
- 函数参数的默认值
- 遍历map结构
- 输入模块的指定方法