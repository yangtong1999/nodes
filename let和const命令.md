### 第二章 let和const命令

##### let命令

用于声明变量，相当于var，所声明的变量只在let命令所在的代码块内部有效。

for循环设置循环变量的那部分是一个父级作用域，循环体内部是一个单独的子作用域。

###### 变量提升：变量可以在声明之前使用。var可以，值为undefined，let改变了这一种情况，所声明的变量一定要在声明之后使用。

暂时性死区：块级作用域中存在let命令，所声明的变量就绑定这个区域，形成封闭作用域，不会受到外界的影响。

不允许重复声明：let不允许在相同的作用域里面重复声明同一个变量。

所以，不能在函数内部重新声明参数。


```
function func(arg){
    let arg;//报错
}
function func(arg){
    {
        let arg;
    }
}
```
在for循环中，循环体内定义变量i控制循环，但在循环结束后，i没有消失，泄露成为全局变量。

let为JavaScript增加了块级作用域，声明相同变量，外层代码块不受内层代码块的影响。

意味着内层作用域可以定义外层作用域的同名变量。

ES6规定，在块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

函数声明问题：

- 允许在块级作用域中声明函数。
- 函数声明类似于var，会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。

避免在块级作用域中声明函数，如果需要，应该写成函数表达式的形式，而不是函数声明语句。

函数表达式的形式：

```
{
    let a = 'secret';
    let f = function(){
        return a;
    }
}
```
ES6 块级作用域允许声明函数的规则只在使用大括号的情况下成立，如果没有使用大括号，则会报错

###### do 表达式

块级作用域是一个语句，将多个操作封装在一起，没有返回值

在块级作用域之前加上do，使它变成do表达式。


```
let x = do {
    let t = f();
    t*t + 1;
};//变量x会得到整个作用域的返回值
```
##### const 命令
const声明一个只读的常量，一旦声明，常量的值就不能改变

```
const PI = 3.1415;
PI //3.1415
```
const一旦声明常量，就必须立即初始化，不能留到以后赋值。

const只声明不赋值会报错，只在声明所在的块级作用域中有效。

const命令声明的常量也不会提升，同样存在暂时性死区，只能在声明后使用

const不可重复声明

###### 本质
const实际上保证的并不是变量的值不可改动，而是变量指向的那个内存地址不可改动


```
const foo = {}；
//为foo添加一个属性，可以成功
foo.prop = 123;
foo.prop //123

//将foo指向另一个对象，就会报错
foo = {};
//TypeError:"foo"is ready-only
```
foo指向的是一个地址，这个地址指向一个对象，这个地址指向对象，不可变的是这个地址，即不能把变量foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

Object.freeze方法：将对象冻结


```
const foo = Object.freeze({});
//常规模式下，下面一行不起作用
//严格模式时，该行会报错
foo.prop = 123;//添加新属性不起作用
```
###### 声明变量的6种方法：var function let const import class；
###### 顶层对象的属性
顶层对象：在浏览器环境中指的是window对象，在Node环境中指的是global对象

ES6的规定：为了保证兼容性，var和function命令声明的全局变量依旧是顶层对象的属性，另一方面规定，let命令、const命令、class命令声明的全局变量不属于顶层对象的属性


```
var a = 1;
window.a //1

let b = 1;
window.b//undefined
```
###### global对象
Node中，顶层对象是global，其他环境都不支持
