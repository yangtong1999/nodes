 函数允许为函数的参数设置默认值，直接写在参数定义的后面。
 
==参数变量是默认声明的，不能用let，或者const再次声明==

使用函数参数默认值的时候，函数不能有同名参数。

参数的默认值不是传值的，而是每次都重新计算默认值表达式的值，参数默认值是惰性求值的。

参数默认值可以与解构赋值的默认值结合使用

非尾部的参数设置默认值，这个参数无法省略。除非显示输入undefined，触发该参数等于默认值，null没有这个效果。

指定默认值之后，函数的length属性将返回没有指定默认值的参数个数。即指定默认值之后，length将会失真。

设置默认值的参数不是尾参数的话，length属性也不会计入后面的参数。

函数的name属性返回该函数的函数名

#### 箭头函数

```
var f = v => v;
//等价于以下代码
var f = function(v){
    return v;
}
```
箭头函数不需要参数或者需要多个参数可以使用圆括号代表参数部分。


```
var f = () => 5;
//等价于
var f = function(){
    return 5;
}

var sum = (sum1 + sum2) =>num1 +num2;
//等同于
var sum = function(sum1,sum2){
    return sum1 + sum2;
}
```
如果箭头函数的代码部分语句多过一条语句，就要用大括号将其括起来，使用return语句返回。

如果箭头函数直接返回一个对象，必须在对象的外面加上括号。


```
const full = ({first,last}) =>first +'' +last;
//等同于
function(person){
    return person.first +'' +person.last;
}
```
====箭头函数的作用是简化回调函数====

##### 箭头函数的注意事项

- 函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象。
- 不可以当做构造函数，也就是说，不可以使用new命令，否则会抛出错误。
- 不可以使用arguments对象，该对象在函数体内不存在。要用的话，使用rest命令代替。
- 不可以使用yield命令，箭头函数不能做Generator函数

==this的对象是可变的，但在箭头函数里面它是固定的，指向函数定义生效时所在的对象==

箭头函数让setTimeout里面的this绑定定义时所在的作用域，而不是指向运行时所在的作用域。

**箭头函数根本没有自己的this，而是引用外层的this**

**arguments和super、new.tarrget在箭头函数中也是不存在的，分别指向外层的对应变量**

不能使用call(),apply(),bind()这些方法去改变this的指向

箭头函数内部还可以在使用箭头函数。

##### 尾调用优化

尾调用：某个函数的最后一步是调用另一个函数。

不一定出现在函数尾部，只要是最后一步就好。

尾调用优化：直接用内层函数的调用帧取代外层函数的即可

##### 尾递归

尾调用自身就称为尾递归

只要使用尾递归，就不会发生栈溢出。

柯里化：多参数的函数转换成为单参数的形式

**尾调用模式仅仅在严格模式下开启，正常模式无效**

理由：在正常模式下函数内部有两个变量，可以跟踪函数的调用栈




